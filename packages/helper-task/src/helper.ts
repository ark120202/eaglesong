import { ServiceConstructor, ServiceMap, ServiceProvider } from '@eaglesong/helper-service';
import chokidar from 'chokidar';
import fs from 'fs-extra';
import globby from 'globby';
import { AsyncParallelHook } from 'tapable';
import path from 'upath';
import vdf, { StringifyOptions } from 'vdf-extra';
import { ReadonlyTaskMap, TaskProvider } from './tasks';
import { _import } from './utils';

const DEFAULT_KV_HEADER = `// This file is generated by Eaglesong.
// Don't edit it manually. All your changes will be lost.

`;

export interface OutputOptions extends StringifyOptions {
  header: boolean | string | ((input: object) => string);
}

export interface WatchEvent {
  event: 'add' | 'change' | 'unlink';
  file: string;
}

type _hooks = ReturnType<typeof createHooks>;
export interface Hooks extends _hooks {}
export const createHooks = () => ({
  definitions: new AsyncParallelHook<[string]>(['definitionsPath']),

  boot: new AsyncParallelHook<[]>([]),

  build: new AsyncParallelHook<[]>([]),

  compile: new AsyncParallelHook<[(patterns: string | string[]) => void]>(['addResource']),

  changelog: new AsyncParallelHook<
    [
      {
        write(message: string): void;
        oldTaskProvider: TaskProvider;
        oldServiceProvider: ServiceProvider;
      }
    ]
  >(['options']),
});

export class BuildHelper {
  public constructor(
    public readonly context: string,
    public readonly dotaPath: string | undefined,
    public readonly addonName: string,
    private readonly outputOptions: Partial<OutputOptions>,
    private readonly services: ServiceMap,
    public readonly hooks: Readonly<Hooks>,
    private readonly tasks: ReadonlyTaskMap,
    public readonly isWatching: boolean,
    private readonly flags: Record<string, boolean>,
  ) {}

  public async matchFiles(patterns: string | string[]) {
    return (await globby(patterns, { cwd: this.context, absolute: true })).map(path.toUnix);
  }

  public watch(patterns: string | string[], callback: (info: WatchEvent) => void) {
    if (!this.isWatching) return;

    const watcher = chokidar.watch(patterns, { ignoreInitial: true, cwd: this.context });
    const toPath = (fileName: string) => path.resolve(this.context, fileName);
    watcher.on('add', file => callback({ event: 'add', file: toPath(file) }));
    watcher.on('change', file => callback({ event: 'change', file: toPath(file) }));
    watcher.on('unlink', file => callback({ event: 'unlink', file: toPath(file) }));
  }

  public async outputKV1(filePath: string, data: Record<string, any>) {
    if (!path.isAbsolute(filePath)) throw new Error('Expected absolute file path');

    const { header = true } = this.outputOptions;

    let fileContent = vdf.stringify(data, this.outputOptions);
    if (header !== false) {
      const headerMessage =
        typeof header === 'function' ? header(data) : header === true ? DEFAULT_KV_HEADER : header;

      fileContent = headerMessage + fileContent;
    }

    await fs.outputFile(filePath, fileContent);
  }

  public async import(id: string) {
    return _import(id);
  }

  public resolvePath(request: string): string;
  public resolvePath(root: 'project' | 'game' | 'content', request: string): string;
  public resolvePath(arg1: string, arg2?: string) {
    const request = arg2 != null ? arg2 : arg1;
    const root = arg2 != null ? (arg1 as 'project' | 'game' | 'content') : 'project';

    if (path.isAbsolute(request)) return request;
    switch (root) {
      case 'project':
        return path.join(this.context, request);
      case 'game':
      case 'content':
        return path.join(this.dotaPath, root, 'dota_addons', this.addonName, request);
    }
  }

  public taskProvider: TaskProvider = key => this.tasks.get(key);
  public serviceProvider: ServiceProvider = key => this.services.get(key);
  public registerService(service: object) {
    this.services.set((service.constructor as unknown) as ServiceConstructor, service);
  }

  public hasFlag(flag: string) {
    return Boolean(this.flags[flag]);
  }
}
