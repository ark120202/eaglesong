import fs from 'fs-extra';
import _ from 'lodash';
import MemoryFS from 'memory-fs';
import pProps from 'p-props';
import path from 'path';
import readPkg from 'read-pkg';
import resolveFrom from 'resolve-from';
import { promisify } from 'util';
import webpack, { DllPlugin } from 'webpack';
import WebpackChain from 'webpack-chain';

export interface Manifest {
  name: string;
  content: Record<string, { id: string; buildMeta: any }>;
}

export interface Cache {
  time: number;
  isWatching: boolean;
  versions: Record<string, string>;
  manifest: Manifest;
}

export interface Common {
  modules: string[];
  lifetime: number | 'forever' | 'compiler';
  preserveRealm: boolean;
}

export async function loadCache(
  cacheFilePath: string,
  commons: string[],
): Promise<Record<string, Cache>> {
  try {
    return _.pick(await fs.readJson(cacheFilePath), commons);
  } catch {
    return {};
  }
}

export async function resolveVersions(context: string, modules: string[]) {
  return _.fromPairs(
    await Promise.all(
      modules.map<Promise<[string, string]>>(async moduleName => {
        const resolved = resolveFrom(context, `${moduleName}/package.json`);
        if (resolved === null) return [moduleName, 'exotic'];
        // @ts-ignore
        const pkg = await readPkg({ cwd: path.dirname(resolved) });
        return [moduleName, pkg.version];
      }),
    ),
  );
}

async function isDirty(isWatching: boolean, context: string, common: Common, cached?: Cache) {
  if (cached == null) return true;

  if (common.lifetime === 'compiler') return true;
  if (typeof common.lifetime === 'number' && cached.time + common.lifetime >= Date.now()) {
    return true;
  }
  if (cached.isWatching !== isWatching) return true;

  return !_.isEqual(cached.versions, await resolveVersions(context, common.modules));
}

export async function getDirtyCommons(
  isWatching: boolean,
  context: string,
  common: Record<string, Common>,
  cache: Record<string, Cache>,
) {
  const cacheStatus = await pProps(common, (cfg, n) => isDirty(isWatching, context, cfg, cache[n]));
  return _.keys(_.pickBy(cacheStatus));
}

export function makeConfigs(
  webpackContext: string,
  isWatching: boolean,
): [WebpackChain, WebpackChain] {
  const bannerOptionsJs: webpack.BannerPlugin.Options = {
    banner: `This file is generated by Eaglesong.
  name:      [name]
  file:      [file]
  hash:      [hash]
  chunkhash: [chunkhash]`,
    test: /\.js$/,
  };
  const [sameRealmCfg, otherRealmCfg] = [new WebpackChain(), new WebpackChain()];
  [sameRealmCfg, otherRealmCfg].forEach(c =>
    c
      .devtool(false)
      .context(webpackContext)

      .output.path('/')
      .filename('[name].js')
      .end()

      .plugin('dll')
      .use(DllPlugin, [{ path: '/[name].json' }])
      .init((plugin, args) => new plugin({ ...args[0], name: c.output.get('library') }))
      .end()

      .plugin('banner-js')
      .use(webpack.BannerPlugin, [bannerOptionsJs])
      .end()

      // @ts-ignore
      .mode(isWatching ? 'development' : 'production'),
  );
  sameRealmCfg.output.library('__eaglesong_module__[name]');
  otherRealmCfg.output.library('GameUI.__eaglesong_module__[name]').libraryTarget('assign');
  return [sameRealmCfg, otherRealmCfg];
}

export async function runCompiler(
  isWatching: boolean,
  context: string,
  outputPath: string | undefined,
  commons: Record<string, Common>,
  [sameRealmCfg, otherRealmCfg]: [WebpackChain, WebpackChain],
) {
  _.each(commons, ({ modules, preserveRealm }, name) =>
    (preserveRealm ? sameRealmCfg : otherRealmCfg).entry(name).merge(modules),
  );

  const mfs = new MemoryFS();
  await Promise.all(
    [sameRealmCfg, otherRealmCfg].map(async c => {
      if (c.entryPoints.values().length === 0) return;

      const compiler = webpack(c.toConfig());
      // @ts-ignore
      compiler.outputFileSystem = mfs;
      const stats = await promisify(compiler.run).call(compiler);
      // FIXME:
      if (stats.hasErrors() || stats.hasWarnings()) console.error(stats.toString()); // throw new Error(stats.toString());
    }),
  );

  if (outputPath != null) {
    await Promise.all(
      Object.keys(commons).map(name =>
        fs.outputFile(
          `${outputPath}/scripts/${name}.js`,
          mfs.readFileSync(`/${name}.js`, 'utf8'),
          'utf8',
        ),
      ),
    );
  }

  const manifests = _.mapValues(commons, ({ preserveRealm }, name) => {
    const manifest: Manifest = JSON.parse(mfs.readFileSync(`/${name}.json`, 'utf8'));

    // TODO: Think of some better way
    if (!preserveRealm) {
      const key = Object.keys(manifest.content).find(x => x.endsWith('webpack/buildin/global.js'));
      if (key != null) delete manifest.content[key];
    }

    return manifest;
  });

  const time = Date.now();
  return pProps(
    manifests,
    async (manifest, name): Promise<Cache> => ({
      time,
      isWatching,
      versions: await resolveVersions(context, commons[name].modules),
      manifest,
    }),
  );
}
