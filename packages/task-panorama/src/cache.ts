import fs from 'fs-extra';
import _ from 'lodash';
import MemoryFS from 'memory-fs';
import pProps from 'p-props';
import path from 'path';
import readPkg from 'read-pkg';
import resolveFrom from 'resolve-from';
import { promisify } from 'util';
import webpack from 'webpack';

export interface Manifest {
  name: string;
  content: Record<string, { id: string; buildMeta: any }>;
}

export interface Cache {
  time: number;
  isWatching: boolean;
  versions: Record<string, string>;
  manifest: Manifest;
}

export interface Common {
  modules: string[];
  lifetime: number | 'forever' | 'compiler';
  preserveRealm: boolean;
}

export async function loadCache(
  cacheFilePath: string,
  commons: string[],
): Promise<Record<string, Cache>> {
  try {
    return _.pick(await fs.readJson(cacheFilePath), commons);
  } catch {
    return {};
  }
}

export async function resolveVersions(context: string, modules: string[]) {
  return _.fromPairs(
    await Promise.all(
      modules.map<Promise<[string, string]>>(async moduleName => {
        const resolved = resolveFrom(context, `${moduleName}/package.json`);
        if (resolved === null) return [moduleName, 'exotic'];
        // @ts-ignore
        const pkg = await readPkg({ cwd: path.dirname(resolved) });
        return [moduleName, pkg.version];
      }),
    ),
  );
}

async function isDirty(isWatching: boolean, context: string, common: Common, cached?: Cache) {
  if (cached == null) return true;

  if (common.lifetime === 'compiler') return true;
  if (typeof common.lifetime === 'number' && cached.time + common.lifetime >= Date.now()) {
    return true;
  }
  if (cached.isWatching !== isWatching) return true;

  return !_.isEqual(cached.versions, await resolveVersions(context, common.modules));
}

export async function getDirtyCommons(
  isWatching: boolean,
  context: string,
  common: Record<string, Common>,
  cache: Record<string, Cache>,
) {
  const cacheStatus = await pProps(common, (cfg, n) => isDirty(isWatching, context, cfg, cache[n]));
  return _.keys(_.pickBy(cacheStatus));
}

export function makeConfigs(
  webpackContext: string,
  isWatching: boolean,
): [webpack.Configuration, webpack.Configuration] {
  const [sameRealmCfg, otherRealmCfg] = [true, false].map(
    (isOtherRealm): webpack.Configuration => {
      const library = isOtherRealm
        ? 'GameUI.__eaglesong_module__[name]'
        : '__eaglesong_module__[name]';

      return {
        entry: {},
        mode: isWatching ? 'development' : 'production',
        devtool: false,
        context: webpackContext,
        output: {
          path: '/',
          filename: '[name].js',
          library,
          libraryTarget: isOtherRealm ? 'assign' : undefined,
        },
        plugins: [
          new webpack.DllPlugin({ path: '/[name].json', name: library }),
          new webpack.BannerPlugin({
            test: /\.js$/,
            banner: `This file is generated by Eaglesong.
  name:      [name]
  file:      [file]
  hash:      [hash]
  chunkhash: [chunkhash]`,
          }),
        ],
      };
    },
  );

  return [sameRealmCfg, otherRealmCfg];
}

export async function runCompiler(
  isWatching: boolean,
  context: string,
  outputPath: string | undefined,
  commons: Record<string, Common>,
  [sameRealmCfg, otherRealmCfg]: [webpack.Configuration, webpack.Configuration],
) {
  for (const [name, { modules, preserveRealm }] of Object.entries(commons)) {
    const entry = (preserveRealm ? sameRealmCfg : otherRealmCfg).entry as webpack.Entry;
    entry[name] = modules;
  }

  const mfs = new MemoryFS();
  await Promise.all(
    [sameRealmCfg, otherRealmCfg].map(async config => {
      const isEmptyConfig =
        config.entry == null ||
        (typeof config.entry === 'object' &&
          (Array.isArray(config.entry) ? config.entry : Object.keys(config.entry)).length === 0);

      if (isEmptyConfig) {
        return;
      }

      const compiler = webpack(config);
      // @ts-ignore
      compiler.outputFileSystem = mfs;
      const stats = await promisify(compiler.run).call(compiler);
      // FIXME:
      if (stats.hasErrors() || stats.hasWarnings()) console.error(stats.toString()); // throw new Error(stats.toString());
    }),
  );

  if (outputPath != null) {
    await Promise.all(
      Object.keys(commons).map(name =>
        fs.outputFile(
          `${outputPath}/scripts/${name}.js`,
          mfs.readFileSync(`/${name}.js`, 'utf8'),
          'utf8',
        ),
      ),
    );
  }

  const manifests = _.mapValues(commons, ({ preserveRealm }, name) => {
    const manifest: Manifest = JSON.parse(mfs.readFileSync(`/${name}.json`, 'utf8'));

    // TODO: Think of some better way
    if (!preserveRealm) {
      const key = Object.keys(manifest.content).find(x => x.endsWith('webpack/buildin/global.js'));
      if (key != null) delete manifest.content[key];
    }

    return manifest;
  });

  const time = Date.now();
  return pProps(
    manifests,
    async (manifest, name): Promise<Cache> => ({
      time,
      isWatching,
      versions: await resolveVersions(context, commons[name].modules),
      manifest,
    }),
  );
}
